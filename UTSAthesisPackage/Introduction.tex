\chapter{Introduction}
\label{chapter:introduction}
Unity is one of the most popular cross-platform game engines that is designed to support and develop 2D and 3D video games, simulations for computers, virtual reality, consoles and mobile devices platform~\cite{UnityDoc}. This engine can also be used to  make high quality games, design and develop 3D social network gaming platforms~\cite{bae2014}. Unity is also used to create some VR/AR applications, that are used for various medical, education or business purposes. The main advantage of Unity 3D is that the editor runs on Windows and Mac OS X and can produce  games for Windows, Mac, Web browsers, Wii, iOS (iPhone, iPod, Touch, and iPad), Android, Xbox 360, and Playstation 3~\cite{Macedo2011}. For game developers who want to start game development, Unity is an excellent and recommended platform~\cite{Buyuksalih2017}. Developers can save time and effort because of complete toolset, intuitive workspace and on the-fly play testing and editing feature of Unity~\cite{Kim2014}. Unity applications have been downloaded onto over 3 billion devices worldwide and applications made with the Unity engine have been downloaded over 24 billion times in the last 12 months~\cite{FeaturesUnity}. Apart from Unity's all these advantages and popularity, researchers have found that Unity game platform perform slower than other engines~\cite{Buyuksalih2017}. And inspite of this, no research has been done regarding Unity's performance issue. 

Among all the non-functional properties of programs, performance is the most important one~\cite{Kim2016,Woodside2007}. Software performance describes a software program's overall standard. Performance bug- programming error, inefficient source code can cause software quality or performance to deteriorate. It can result in poor user experience, deteriorated responsiveness, wasted computational resources~\cite{molyneaux2009,bryant2003}. So, industry and research community have spent great effort to address performance bugs. But performance of modern game engines have never been formally analyzed~\cite{messaoudi2015}. That means, till now Unity's performance bugs or issues have not been addressed. Therefore, it is important to investigate which types of performance bugs mostly fixed in Unity to guide researchers and developers further working on detecting, localizing and fixing performance bugs of Unity.

For this purpose, first of all we downloaded 100 open source Unity projects from GitHub and created a dataset of 230 performance bug fixing commits from those projects. For choosing projects, we prioritized the projects with more than 100 commits, which is a indication that these are well-maintained projects. To find the performance commits we programmatically searched for some keywords in the commit messages and found 588 probable performance commits. To make sure if these commits are actually related to performance, we did manual analysis and finally got 230 actual performance commits.

With detailed root cause analysis, we identified Unity's performance bug fix taxonomy. That means, we categorized the bugs depending on their types and how they got fixed. This taxonomy can Be used for static analysis to find performance bugs and also generate automatic fix suggestions.

With AST level code change analysis, we provided some statistics regarding the types of methods that are prone to performance bugs, both with and without considering call-graph analysis and we found that Unity's call-back methods are prone to performance bugs. This gives an indication for developers that they should be more careful while writing Unity's call-back methods. We also tried to analyze the performance bug fix complexity in terms of Class, Method and Statement Change and found that performance Bugs Are complex in nature and require to change in multiple code locations. Finally to find the location of the bug fixes, we did the commit message analysis and identified that apart from source code related bugs, performance bugs can happen due to Unity GameObject Asset/Prefab Issues.

Summing up the above discussion, our study makes the following contributions:
\begin{itemize}
	\item We prepared a dataset of Unity performance bugs that we used for our analysis and this data can also be used for future research. 
	\item We generated Unity's performance bug taxonomy that can be used for static analyzer and automatic program repair techniques.
	\item Our analysis on performance bug identifies the nature or complexity of the bugs and gives idea about the bug prone methods.
	\item We also found that for performance bug we need to fix in the asset/prefab files apart from source code. 
\end{itemize}

The remaining part of this paper is organized as follows. After presenting a background related to \unity and performance analysis in Section~\ref{chapter:background}, we describe our experiment methodology in Section~\ref{chapter:methodology}. Section~\ref{chapter:empevaluation} presents the evaluation of our analysis, while Section~\ref{chap:discussions} presents discussion. Related works and Conclusion will be discussed in Section~\ref{chap:relatedwork} and Section~\ref{chap:conclusion}, respectively.