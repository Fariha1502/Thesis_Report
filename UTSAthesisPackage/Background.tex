\chapter{Background}
\label{chapter:background}
The purpose of this section is to provide the background of this study. Before going into details about my research work, I would like to discuss about some key terminology that we used in our work.

\section{Unity}
With ever-increasing demands of VR or AR application and Game Applications, developers are working with Unity Framework. Unity provides convenient integrated development environment through C\# programming scripts. I would like to discuss about four basic terminology of Unity: \textbf{Gameobject}, \textbf{Asset}, \textbf{Prefab}, \textbf{Scripts}. The most important concept in the Unity editor is Gameobject. Gameobjects are the fundamental objects representing any kind of character, scenery, environment etc. But a gameobject cannot do anything on its own, it has no value without its properties. A gameobject acts as a container, to which you can add different components~\cite{Gameobject}. Any type of item that you can use in your game or program is an Asset. Assets can be created within Unity such as, animator controller, audio mixer etc. Assets may also come from a file that is created outside of Unity, such as, 3D model, audio file etc~\cite{Asset}. A gameobject can be created, configured and stored with all its components, properties, as well as with its child gameobject as a reusable asset and this is allowed by Unity's Prefab. That means, a prefab is a copy of a game object converted into a reusable asset New prefab instances can be created in the scene by using prefab asset as a template~\cite{Prefab}. In Unity you can create your own components using Scripts. By using scripts, you can take assets in your scene and make them interactive. For scripts Unity supports the C\# programming language~\cite{Script}.

\section{Abstract Syntax Tree Based Code Differencing}
To analyze and verify a program, code representation is a necessary step. An abstract syntax tree (AST) is used to represent the syntax of a programming language as a hierarchical tree-like structure. AST is one type of data structure that represents program structures to reason about syntax and semantics. All of the syntactical elements of the programming language are represented by AST. It focuses on the rules rather than elements that terminate statements. In AST each programming statement are broken down recursively into their parts and each node in the tree denotes a construct occurring in the programming language~\cite{Koyuncu}.

To study software evolution, differencing two versions of a program is the main pre-processing step. The evolved parts must be captured in an easy and understandable way. Text-based differencing tools are normally used by the developers, but the problem is that it does not provide a fine-grained  representation of the change. That's why it is poorly suited for systematically analysing the changes. Recent algorithms have been
proposed based on tree structures (such as the AST) to address this issue of code differencing, such as, ChangeDistiller and GumTree. These algorithms produce edit scripts that present detail operations to be performed on the nodes of a given AST to yield another AST corresponding to the new version of the code~\cite{Koyuncu, martinez2019}. 

\section{Call Graph}
A call graph represents calling relationships between subroutines/functions of a program. In a call graph, each node represents a procedure and every edge (a,b) indicates that procedure a calls procedure b. A call graph is a necessary prerequisite for most interprocedural analyses used in compilers, verification tools and program understanding tools~\cite{lhotak2007}. There are two types of call graphs: dynamic, static. Dynamic call graph is a record of an execution of the program. It can be exact but it only describes that particular run of the program. On the other hand, static call graph represents every possible run of the program~\cite{wiki:call}.

Call Graphs are widely used for Test Case Prioritization~\cite{luo2016large} and Test Case Selection~\cite{legunsen2016extensive}. For test case prioritization and selection, call graphs are used to obtain list of transitively relevant methods. Based on call graph analysis, test case with a higher number of invocation are prioritized or selected for regression. Apart from that, call graph is also used in change impact analysis~\cite{Musco2017}. Change in a single commit might impact or break whole software or package. To identify impact of changes, one common approach is to perform change impact analysis. In change impact analysis call graph is also used to identify transitively relevant methods that can impacted due to recent changes. 
